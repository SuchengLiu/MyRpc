# MyRpc
参考dubbo的轻量级rpc框架。

RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。

主要模块：协议模块、序列化模块、网络模块、server模块、client模块、注册中心模块以及负载均衡模块

## 协议模块
Peer：表示网络传输的实体，用ip+port表示一个网络实体

Request：表示RPC的请求实体，包含服务描述法和方法参数值

Response：表示RPC的响应实体，包含响应码、返回的数据或错误信息

ServiceDescriptor：表示服务描述符，包含服务接口名、方法名、方法返回类型以及方法参数类型。重写了hashCode()和equals()方法

## 序列化模块
包括序列化和反序列化。

提供了基于FastJSON的实现

## 网络模块
网络传输部分使用Http协议进行传输。

客户端使用`HttpURLConnection`类创建和管理与Http服务器之间的连接。

- 客户端负责
  1. 建立连接
  2. 发送数据，并等待响应
  3. 关闭连接

服务端使用Jetty作为Http服务器。

`ServletContextHandler`类是Jetty中用于处理Servlet请求和管理Servlet上下文的关键组件。它提供了一种将Servlet与特定路径和上下文相关联的机制。允许在Jetty服务器上定义多个Servlet上下文，每个上下文都有自己的配置和处理规则。

`ServletHolder`类是Jetty服务器中用于持有Servlet实例的类。用于创建和管理Servlet实例，并将其添加到Jetty服务器的上下文中。

`RequestHandler`类是网络请求的处理器，在server模块的`RpcServer`类中实现了具体的处理逻辑

- 服务端
  1. 启动并监听端口
  2. 等待客户端连接，收到请求后处理
  3. 关闭监听

## server模块
rpc服务器负责
1. 注册和管理服务接口与服务提供者（服务实现类）
2. 向注册中心注册自己提供的服务

`ServiceManager`通过`ConcurrentHashMap`管理服务接口与服务实现类；通过反射机制获取服务接口暴露的方法。

`ServiceInvoker`通过反射机制调用具体的方法实现

## client模块
rpc客户端通过JDK动态代理生成服务代理对象，封装了远程调用的细节

代理对象调用任何方法时都会把方法类型和参数信息交给invoke函数；
invoke函数负责给服务端发送请求，请求体中包含接口名，方法名和方法返回类型，参数类型和参数实际值；
服务端收到请求后，根据请求体中的信息找到对应服务（函数）,和提供服务的对象。通过反射调用对应的方法。

远程调用过程中，rpc客户端向注册中心订阅服务提供者列表，并基于负载均衡策略选择一个服务提供者

## 注册中心模块
提供了服务注册和服务订阅的功能

基于Zookeeper实现的注册中心
1. /rpc-service作为跟znode
2. 服务名称作为次级znode
3. 理论上，下层的znode为对应的类型，provider或者consumer，再下层是对应类型的机器，由ip+port构成路径的临时znode
4. 实际实现中，没有使用consumer类型，只有provider类型才向注册中心注册，因此将后两层简化为一层

基于Zookeeper实现的服务订阅机制
1. 先从本地缓存获取服务的提供者列表，获取不到再从zookeeper获取
2. 从zookeeper获取子节点时，Watcher 会被注册到指定节点的子节点上，用于监视子节点的变化。若子节点有变化，则重新获取最新子节点
3. 将zookeeper拉取的子节点信息转换为服务提供至列表，并存入本地缓存
4. 本地缓存的map可能存在并发安全问题 同时读写(subscribe读，watcher写)，因此使用ConcurrentHashMap实现

## 负载均衡模块
提供了随机负载均衡与一致性哈希负载均衡

一致性哈希负载均衡
1. 映射服务：将服务地址（ip+端口）按照一定规则构造出特定的识别码（如md5码），再用识别码对2^32取模，确定服务在Hash值区间对应的位置。
2. 映射请求、定位服务：在发起请求时，我们往往会带上参数，而这些参数，就可以被我们用来确定具体调用哪一个服务。我们取服务Hash值大于请求Hash值的第一个服务作为实际的调用服务。
3. 新增服务节点、删除服务节点受影响的请求是有限的。
4. 平衡性与虚拟节点：所谓虚拟节点，就是除了对服务本身地址进行Hash映射外，还通过在它地址上做些处理（比如Dubbo中，在ip+port的字符串后加上计数符1、2、3……，分别代表虚拟节点1、2、3），以达到同一服务映射多个节点的目的。通过引入虚拟节点，请求的分布就会比较平衡了。
